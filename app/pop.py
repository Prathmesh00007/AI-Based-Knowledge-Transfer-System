# populate_project_entries.py

import uuid
import datetime
from pymongo import MongoClient
from config import settings  # Ensure the correct path based on your project structure
from pipeline import run_pipeline

# A list of 30 sample, project-relevant Jira ticket texts.
# In a real scenario, these would be based on actual project incidents.
SAMPLE_TICKETS = [
    "MCC-201: The login page is unresponsive on Safari. Users report timeouts and blank screens.",
    "MCC-202: API /v1/users returns 500 error during peak hours. Investigate rate limits and firewall issues.",
    "MCC-203: Data synchronization between the CRM and the billing system is failing intermittently.",
    "MCC-204: The new deployment script caused the production environment to crash unexpectedly.",
    "MCC-205: UI components break on mobile devices after the latest CSS update. Check responsive design rules.",
    "MCC-206: Payment gateway integration error after recent update. The system fails to validate transaction tokens.",
    "MCC-207: Error 404 encountered on the dashboard when users attempt to load analytics reports.",
    "MCC-208: The caching layer is causing stale data to be displayed on the user profile page.",
    "MCC-209: API response times degraded by 300% post-maintenance. Likely caused by inefficient database queries.",
    "MCC-210: SMTP server configuration issue leads to missing email notifications for new ticket submissions.",
    "MCC-211: The system logs cluttered with duplicate entries following the recent logging service migration.",
    "MCC-212: Bug in module X causes the system to hang when processing large datasets.",
    "MCC-213: Cron job for data backup fails intermittently; check network stability and disk I/O rates.",
    "MCC-214: Microservice Y unexpectedly restarts due to memory leaks detected after prolonged operation.",
    "MCC-215: Security scan reveals outdated libraries with known vulnerabilities in the authentication module.",
    "MCC-216: API /v2/inventory shows incorrect counts on items; inventory sync process may have bugs.",
    "MCC-217: Payment processing failure on the checkout page; error messages indicate issues with encryption.",
    "MCC-218: The video streaming component lags severely, causing playback issues for end users.",
    "MCC-219: Database replication delay detected; causing read operations to return out-of-date information.",
    "MCC-220: Image upload functionality broken after frontend merge; images fail to appear in the gallery.",
    "MCC-221: File export to CSV produces malformed files, making it impossible to import data elsewhere.",
    "MCC-222: The new feature toggle for beta users does not operate as expected, causing feature exposure.",
    "MCC-223: Multiple users report that the application's dark mode is not persisting across sessions.",
    "MCC-224: Error encountered during bulk user import; some records are skipped without notification.",
    "MCC-225: A memory spike observed when processing new leads in the CRM integration module.",
    "MCC-226: The dashboard charts fail to render on Internet Explorer, likely due to unsupported CSS features.",
    "MCC-227: Lag in real-time chat notifications; increasing server load may be the culprit.",
    "MCC-228: System experiencing intermittent downtime; preliminary logs suggest network misconfiguration.",
    "MCC-229: The user settings page returns a 'Service Unavailable' error during high traffic.",
    "MCC-230: Scheduled report generation fails with a timeout error, indicating potential backend overload."
]

def populate_db_with_pipeline_entries():
    client = MongoClient(settings.MONGO_URI)
    db = client[settings.DB_NAME]
    collection = db[settings.COLLECTION_NAME]

    # Optional: clear existing documents
    collection.delete_many({})

    all_documents = []
    # Iterate over 30 sample tickets and process each using the pipeline.
    for i, ticket_text in enumerate(SAMPLE_TICKETS, start=1):
        # Here, we invoke the pipeline for each sample ticket.
        # run_pipeline returns a list of documents (typically one document per raw text).
        pipeline_output = run_pipeline(ticket_text, source_id=f"MCC-{200+i}")
        # Extend our master list with documents from this ticket.
        all_documents.extend(pipeline_output)

    if all_documents:
        result = collection.insert_many(all_documents)
        print(f"Inserted {len(result.inserted_ids)} documents into the collection.")
    else:
        print("No documents were generated by the pipeline.")

    client.close()

if __name__ == "__main__":
    populate_db_with_pipeline_entries()
